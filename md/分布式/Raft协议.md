# Raft基本流程

1. Raft集群结点类型总是处于三种状态之一：**领导者（Leader）**，**跟随者（Follower）**，**候选人（Candidate）**

   > - Leader：处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）以及和所有Follower通信
   > - Follower：只响应来自Leader和Candidate的请求
   > - Candidate：只在选举新领导人时使用

2. 初始化时集群中所有的节点均为 **Follower**，每个Follower 会设置一个随机计时器作为**选举超时时间**，在超时时间内未接收到 **Leader的心跳** 或者 **Candidate 的请求投票**，就会将自己变为**Candidate**

   > - **附加日志 RPC**：由**领导人负责**调用来**复制日志**指令以及**心跳**（heartbeat），若为心跳则日志条目为空
   > - **请求投票 RPC**：由候选人负责调用用来征集选票 

3. 当结点处于 **Candidate** 时会**开始选举过程**，且**重置选举超时时间**

   - 若接收到大多数服务器的选票，那么就变成 **Leader**
   - 若接收到来自新的领导人的附加日志 RPC，转变成 **Follower**
   - 若选举过程超时，再次发起一轮选举，仍然为 **Candidate** 

4. 当结点处于 **Leader**，需要**不断的发送空的附加日志 RPC（心跳）**给其他所有的服务器，接收到客户端的请求后

   1. 首先将附加条目添加到本地日志中
   2. 发送附加日志 RPC给所有服务器，并等待**超过半数**的服务器响应
   3. 将当前日志标记为**已提交并持久化**，然后应用到状态机后返回给客户端

   若 Leader 接收到的 RPC 请求或响应中任期号大于当前任期号，那么就更新当前任期号并切换当前结点状态为 **Follower**

<img src="/Users/zhangzheng/Backup/学习笔记/技术总结/分布式/分布式一致性/pictures/raft状态切换.png" style="zoom: 67%;" />

> Q: Follower在接收到Candidate的请求投票RPC后就不会变成Candidate了么？
>
> A: 不是的，只要在选举超时时间内未接收到Leader的心跳（**附加日志 RPC**），那么Follower就会变成Candidate

## Leader选举

Leader选举由**Follower**在选举超时时间（一般在 150-300 毫秒随机生成）后主动发起，具体流程如下：

1. 转变为**Candidate**

2. 自增当前的任期号（currentTerm）

3. **给自己投票**

4. 重置选举超时计时器

   > 若选举超时时间内未收到响应则重新发起下一轮选举

5. 并发向所有服务器发起请求投票 RPC，接收到请求投票 RPC的服务器需要判断任期号和日志条目索引，**只有发起者的任期号和日志条目索引不小于本身时才能返回同意的响应**，且需要执行所有服务器应做的事情

   > 所有服务器应做的事情:
   >
   > 1. 如果接收到的 RPC 请求或响应中，任期号`T > currentTerm`，那么就令 currentTerm 等于 T，并切换状态为跟随者
   > 2. **每一轮任期号只能给一个服务器投票**，默认采用先来先服务的原则

6. 接收到大多数响应后成为Leader

> - 即使使用随机的选举超时时间也无法避免出现多个Candidate，如果多个Candidate获得了相同的投票该怎么办？这一任期会以没有领导人结束，等待下一轮选举的发起以确保**一个任期只可能产生一个Leader**
>
> - 如果出现网络分区，会导致 Follower 不断尝试竞选 Leader 导致任期非常高，在网络分区结束后就影响到了原先集群，解决方案是**增加预投票**（只有超过半数的机器认可它的预投票，它才能继续发起正式投票），但是在非对称网络分区时，即使存在预投票也会影响到集群，因此**Follower本地维护了一个时间戳来记录收到 Leader 上一次数据更新的时间，Follower S3 只有超过 election timeout 之后才允许接受预投票请求**
>

## 日志复制

Leader在接收到客户端请求后会向所有Follower发起日志复制，每个结点的日志具有以下两个特性：

- 一旦两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。

  > 第一点能够保证的原因是：**领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，且领导人绝对不会删除或者覆盖自己的日志，只会增加**

- 一旦两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。

  > 第二点能够保证的原因是：**在发送附加日志 RPC 的时候，领导人会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目**。【每个附加日志 RPC请求到Follower时都会进行一致性检查】

因此**日志复制流程**主要如下：

1. Leader接收到了客户端请求后，将请求添加至本地日志（Leader本地日志状态**未提交**）
2. Leader向所有Follower发起附加日志 RPC
3. Follower进行一致性检查，若通过则添加至本地日志并返回成功（Follower本地日志状态**未提交**）
4. Leader接受到半数以上同意后本地日志提交并持久化，然后应用到状态机返回给客户端成功（Leader日志状态**提交**）

上述流程会涉及到几个异常情况：

- Leader发送附加日志 RPC时未收到响应？最简单的处理Leader可以一直等待响应。若客户端超时了自然会重新发起了
- Leader发送附加日志 RPC时收到拒绝响应？这意味着Follower和Leader的日志不一致了。这时候Leader就需要解决不一致问题了

那么**领导者如何解决和跟随者日志不一致**的问题呢？

- 当一个领导者刚选举成功时，为所有Follower初始化所有的 nextIndex 值为自己的最后一条日志的index加1

  > nextIndex: 表示下一个需要发送给跟随者的日志条目的索引地址

- 领导者接收到客户端请求时，向所有Follower发起附加日志 RPC，Follower进行一致性检查，如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败，就会拒绝领导者

- 一旦请求被拒绝，领导者就会减小 nextIndex 值并进行重试直到在某个位置使得领导人和跟随者的日志达成一致，这时Follower就会删除这之后的所有日志并且加上领导人的日志

  > 当然这里用一些优化策略减少被拒绝的附加日志 RPCs 的次数，这里不仔细研究

通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志