## 分布式事务

​	   刚性事务：企图在分布式环境下完成ACID，比如XA。XA协议将参与者（数据库，JMS等资源）定义为**资源管理器**，定义了**事物管理器**作为协调者协调资源管理器的行为。它的常见实现是2PC、3PC。

​		柔性事务：最终一致，衍生出Saga，TCC，MQ。

​		AT： 无侵入的分布式事务解决方案。是seata的主要模式。

​		刚性事务在系统本身不存在问题时，可以保证数据的ACID。柔性事务，只具备最终一致性。



### **TWO-PHASE**：

1. prepare：执行事务但不提交，完成后返回ACK。
2. commit or rollback：prepare阶段收集到所有ACK后执行commit，否则rollback。



​	两阶段提交的模型比较容易理解，MySQL5.5之后也对它进行了支持。但是存在以下问题：

- 事物管理器单点问题。它发生故障之后整个系统将不可用，解决单点问题需要引入集群部署和一致性算法，这是另一个让人头疼的问题了。
- 阻塞时间过长：整个过程相关资源都会被锁定，且锁定时间依赖于最慢的资源管理器。注定了无法支持高并发，而且这种加锁模式很容易造成死锁或阻塞风暴。
- 数据可能不一致：在第二阶段执行过程中无法保证所有资源管理器都完成commit。



### THREE-**PHASE**：

​		将TWO-PHASE中的第一阶段拆为两个步骤，试图降低事务过程中的阻塞。

1. can commit: 询问所有资源管理器是否可以进行某事物。
2. pre commit: 执行事务但不提交，完成后返回ACK。
3. commit or rollback：prepare阶段收集到所有ACK后执行commit，否则rollback。

​		这种改进，确实可以降低2阶段的阻塞范围，但是依然存在其他两个问题。

### [Saga](https://microservices.io/patterns/data/saga.html):

​		Sagas是一连串的本地事务，这些事务是有严格的顺序的。每一个本地事物提交数据后，会触发下一个节点的本地事务，这样依次执行到最后一个节点。它并不像别的模型那样有prepare阶段，每一次执行都是本地事务的提交。

​		如果其中某一个本地事务因为违反了业务规则失败了（tips:不是因为系统故障导致失败），Sagas会逆向执行回滚事务（tips:这里是补偿型的回滚，并不是传统的数据库rollback）。

​		但是Saga不具备隔离性，会产生脏读，更新丢失，不可重复读。且要求每个节点的commit和rollback都具有幂等性。使用者会花费很多精力控制这些事情，这并不是一个好的模型。



### TCC

​		如果seata的AT模式无法被实现，TCC将是最好的分布式事物解决方案。它具有隔离性，而且不会像2PC、3PC那样长时间锁定资源。他们的本质区别是，TCC每次执行都是一个本地事务的提交。

Try: 尝试执行业务
     • 完成所有业务检查(一致性)
     • 预留必须业务资源(隔离性)
Confirm:确认执行业务
     • 真正执行业务
     • 不作任何业务检查
     • 只使用Try阶段预留的业务资源 
     • Confirm操作要满足幂等性
Cancel: 取消执行业务
     • 释放Try阶段预留的业务资源 
     • Cancel操作要满足幂等性

​		try阶段可以理解为一种业务试探，如果所有系统都OK，继续执行confirm，否则执行cancel。注意cancel回滚的是try而不是confirm，一次tcc最终执行的要么是try-confirm，要么是try-cancel。confirm和cancel阶段是不会因为业务原因执行失败的，系统问题可以由重试机制去解决。

举个用户消费的业务场景，用户消费时需要
    ①扣减余额  在A系统中
    ②增加积分  在B系统中
    ③生成订单信息   在C系统中

在TCC 模式下
try阶段：系统A 检查用户余额是否够用，如果不够返回false。如果够冻结部分余额。
        系统B  可以什么都不做直接返回true，加积分一般是不可能失败的。
        系统C  校验并落库一条订单，状态为NOT_AVAILABLE。减库存。

confirm：如果try阶段都返回true，执行confirm。
        系统A：扣除刚才冻结的余额。
        系统B：增加积分。
        系统C：更新订单状态为：AVAILABLE。

cancel： 如果try阶段存在false，执行cancel。
        系统A：解冻刚才冻结的余额。
        系统B：啥也不做。
        系统C：库存+1。


​		TCC能够良好的执行非常依赖子系统的本地事物。如果子系统不支持事务，整个流程是非常繁琐并且不可靠的。比如系统C在T阶段做了两个数据库写操作。如果第二个写操作失败了而系统C不支持事务回滚。此时系统C的cancel阶段就要判断自己应该回滚哪些步骤。当然这种情况也可以将系统C看做是C1，C2来解决。



TCC中每个步骤的职责是怎样划分的？
	  其实这没有标准答案，从单个子系统的角度，这三个步骤的职责是相互制约的。比如系统A、B的操作不变。订单系统C的TCC阶段可以改成：
T：检查商品是否在售，等业务规则。减库存。
Conifrm： 生成订单信息。 
Cancel： 库存+1。



### AT：

​		一种想法特别美好的模型。一种无侵入的分布式事务解决方案，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，框架会自动生成事务的二阶段提交和回滚操作。

- 在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。
- 二阶段提交。二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。
- 二阶段回滚。需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写麻烦就大了，通常不要指望系统可以自动解决。



​		AT模式真可谓处处是难点，可以参考阿里seata对它的实现。



分布式事务统一问题：

​		空回滚：系统并没有收到提交的操作，只是收到了回滚的操作。加入提交操作是增加余额，回滚操作必然就是扣减余额。一旦出现空回滚用户会丢失一笔钱。

​		悬挂：由于网络原因，commit会比rollback晚执行。

> 解决上述两个问题，增加业务幂等号就行了，提交和回滚的时候都根据幂等号找出数据，根据数据的状态判断当前回滚操作或提交操作能不能进行。一般需要用户自己完成相关逻辑的编码，AT模式对这一部分也做了自动化！系统具备应对这两个场景的能力，又被称作“可交换补偿”。记点专业名词总是能忽悠更多msg。



​		系统崩溃：分布式事务对于ACID的保证都是建立在系统本身运行正常时，发生系统崩溃这些保证会被一定程度的破坏。例如隔离性，强一致性肯定不具备了。