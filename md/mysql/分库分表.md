# 分库分表

## 背景

数据量随着业务发展会不断地增长，那么数据操作开销也会越来越大，数据库的性能达到瓶颈，这时候就需要进行分库分表

## 分库 or 分表

这里的抉择其实很简单，就是分库是提高并发能力，或者磁盘容量不够，而分表是为提高单表的查询性能，单表数据量过大，索引膨胀，数据操作开销大

| #            | 分库分表前                   | 分库分表后                                   |
| :----------- | :--------------------------- | :------------------------------------------- |
| 并发支撑情况 | MySQL 单机部署，扛不住高并发 | MySQL从单机到多机，能承受的并发增加了多倍    |
| 磁盘使用情况 | MySQL 单机磁盘容量几乎撑满   | 拆分为多个库，数据库服务器磁盘使用率大大降低 |
| SQL 执行性能 | 单表数据量太大，SQL 越跑越慢 | 单表数据量减少，SQL 执行效率明显提升         |

## 垂直 or 水平

### 垂直拆分

按照功能模块，关系密切度进行拆分，然后部署到不同的库上，比如：用户表一个库，订单表一个库，商品表一个库。

### 水平拆分

把单表按照某个规则拆分成多个表，比如： user 拆成 user_1, user_2

## 分片策略

### 业务特性（地理区域，冷热分离）

### 连续分片（范围分片）

### hash分片（普通取模，一致性哈希）

## 分布式唯一ID

### 数据库自增id

通过数据库的自增id来作为生成器

缺点：每次获取id都得访问数据库

### 数据库多主模式

不同的数据库实例依次从1开始设置不同起始值，设置步长为数据库实例数

缺点：增加数据库，步长值得修改

### 号段模式

每次获取一批连续的id，再本地缓存来使用

### 雪花算法

![雪花算法](https://camo.githubusercontent.com/7ec7eba414b82ace71082e5c176968a9bdab17e4/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f2545392539422541412545382538412542312545372541452539372545362542332539352e706e67)

- 第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。
- 时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年
- 工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。
- 序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID

## 出现的问题

### 事务

采用分布式事务

### 复杂查询



## 中间件

## 流程

