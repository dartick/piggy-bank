1. **Redis优势**：

   - 读写性能优异
   - 支持丰富的数据类型
   - 丰富的功能，如键过期，发布订阅，事务，Pipeline，Lua脚本
   - 持久化，包括 RDB 和 AOF
   - 高可用

2. **数据类型**：字符串，列表，哈希，集合，有序集合。

   - 其中**列表，哈希和有序集合**在**元素数量小于512个且单个字符串不能超过64字节**时使用**压缩列表**，否则分别采用**双端列表，哈希表和跳表**。
   - 而**集合在元素数量小于512个且集合中所有元素都是整数值时使用整数集合**，否则使用**哈希表**

3. **键过期**：

   - 惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除
   - 定期删除：服务器执行定时任务删除过期数据

4. **数据淘汰策略**：

   - **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
   - **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
   - **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
   - **allkeys-lru**：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
   - **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
   - **no-enviction**（驱逐）：不淘汰

5. **事务**：Redis事务允许监控某个Key值变化（乐观更新），一旦出现变化则放弃事务的执行。但需要注意的是**Redis事务并不保证类似Mysql的事务原子性**，Redis事务中任意命令执行失败，其余的命令依然被执行，但会保证其他客户端提交的命令请求不会插入到事务执行命令序列中

6. **流水线**：Pipeline 用于将多个命令统一发送降低多次命令-应答之间的网络交换次数。Redis服务器端需要对多个命令进行切分，客户端则需要将多个命令缓存起来统一发送。**Pipeline 并不保证原子性执行**

7. **Lua脚本**：保证Lua脚本中的指令**原子性执行**

8. **持久化**：分为**RDB持久化**和**AOF持久化**

   - RDB持久化：将当前数据快照保存到硬盘。可通过手动（save/bgsave命令）/ 自动触发（`save m n`），自动触发的原理是当m秒内发生n次变化自动触发bgsave

   - AOF持久化：将每次执行的写命令保存到硬盘。通过配置文件中配置`appendonly yes` 开启 AOF。基本处理流程如下：

     - Redis先将**写命令**追加到**缓冲区aof_buf**

     - 根据不同的同步策略将aof_buf中的内容**同步到硬盘**

     - 定期重写AOF文件用于减少AOF文件的体积

       > AOF重写期间所有写命令全部放入**AOF重写缓冲区**，在重写完毕后父进程把AOF重写缓冲区的数据写入到新的AOF文件，然后替换老文件完成AOF重写

     AOF持久化相对来说是推荐的持久化方案，但每次写都需要持久化到硬盘太影响性能了，因此我们一般每次写入都只写入内核缓冲区，然后每秒进行一次硬盘同步

9. **主从复制**：由从节点发起，如 `slaveof <masterip> <masterport>`，具体流程如下：

   1. 从服务器向主服务器**建立Socket连接**

   2. **数据同步**（全量复制或者部分复制）

      > - 全量复制用于初次复制，主节点会通过RDB快照发送给从结点，期间所有写命令放入复制缓冲区，最后需要把这些写命令再同步到从结点
      > - 部分复制用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点
      >
      > Redis如何确认何时进行全量复制，何时进行部分复制？基本原理是主结点维护一份写命令缓存，且主从双方维护一份复制偏移量offset，如果请求复制时offset后的数据在缓存中就进行部分复制，否则全量复制

   3. **实时同步写命令**以及**维持心跳**

10. **哨兵集群**：Redis 主从结构无法在Master故障时自动切换，哨兵集群主要用于**故障转移**。由于哨兵结点本身也存在单点问题，因此哨兵也会存在自己的集群（经典三结点哨兵集群）。哨兵基本检测流程如下：

    1. 每个哨兵结点都会不断的和监控的Master结点进行ping-pong，哨兵集群进行**主观下线**（当前哨兵结点认为Master结点下线）和**客观下线**（哨兵集群认为Master结点下线）的判断

    2. 第一个检测到客观宕机的哨兵通过 Raft 算法进行 Leader 选举

    3. Leader哨兵进行选举某个 Slave 为 Master

       > - 检测 Slave 跟 Master 断开连接的时长
       > - Slave 优先级
       > - Slave 同步数据的 offset

    4. 根据 Redis `pub/sub` 消息机制向其他哨兵结点同步最新的 Master 配置

11. **Redis集群**：Redis3.0开始的Redis集群包含了故障转移功能，因此不需要哨兵集群，且支持服务端数据路由。经典3主3从6结点集群，只有主结点提供读写服务

    - **开启集群**：每个 Master 结点开启集群模式 -> 节点握手 -> 分配槽 -> 每个 Slave 指定主从关系

    - **哈希槽**：由服务端进行路由，数据hash -> 槽 -> 实际节点。**增加或删除节点**时只需要转移哈希槽

      > 若key所在的槽不在当前节点就会包装目标ip/port并返回MOVED错误重新定向（永久重定向）
      >
      > 在key所在的槽在当前结点，且节点正处于槽迁移过程，就会返回ASK错误重新定向（临时重定向）

    - **Gossip协议**：包含 `ping`,`pong`,`meet`,`fail` 等等。集群中的节点采用固定频率（每秒10次）的定时任务进行Gossip协议通信（一共开放两个端口，一个端口开放给客户端，一个端口用于集群间通信 端口号+10000）

    - **故障转移**：类似哨兵的故障转移原理

    - **客户端**：Dummy客户端：如 redis-cli（借助MOVED错误重新定向）；Smart客户端：如 JedisCluster（客户端维护映射关系）

12. **应用场景**：分布式锁，任务队列，缓存

13. **分布式锁**：

    - 简单的setnx和delete。但存在**当前线程的锁被别的线程释放**的问题
    - 在设置key的时候同时赋予Value为当前线程的唯一值并保存下来用于解锁，且使用Lua脚本保证原子性。但在**Redis集群时Master节点获取到锁后未完成数据同步情况下crash**就会出现异常
    - Redlock，大概原理就是通过多个Redis集群来尽量避免单一结点的影响。但**Redlock是基于timing的分布式锁，存在时钟跳跃问题**

14. **Q&A**：

    - 单线程为什么能保证性能？**完全基于内存，I/O多路复用，不需要加锁解锁以及线程切换**
    - Memcache与Redis的区别？**数据类型，持久化以及Redis集群的服务端路由**

    

