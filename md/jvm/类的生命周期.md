# 类的生命周期

类的生命周期是指一个class从加载到内存直至卸载出内存的过程

## 加载

### 加载来源

1.  从ZIP包中读取，这是后来支持类加载器可从JAR、EAR、WAR等格式文件中加载class的基础。
2.  从网络中获取字节流，我们熟知的Applet是这种场景的典型应用。
3.  程序动态生成字节流，这种场景应用最多的就是动态代理，通过字节码技术动态生成代理类的二进制字节流。
4.  由除了Java源文件之外的其他文件编译而成，如JSP文件、Scala源文件等。

### 步骤

1.  通过一个类的全限定名来获取定义此类的二进制字节流。
2.  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3.  在内存中生成一个代表此类的java.lang.class对象，作为对方法区中此类的各种数据的访问入口。

## 验证

1.  文件格式验证：判断当前字节流是否符合class文件格式的规范。如是否以class文件的魔数oxCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中常量的类型是否合法等等。校验的目的是保证字节流能正确地解析并存储于方法区内，通过验证后，会在方法区中存储，后面的校验动作都是基于方法区的存储结构进行，不再直接操作字节流。
2.  元数据验证：语义分析，判断其描述的信息是否符合Java语言的规范要求。如该类除了java.lang.Object之外，是否有其他父类；该类的父类是否继承了不允许被继承的final类等
3.  字节码验证：通过数据流和控制流分析，判断程序语义是否合法、符合逻辑。如保证跳转指令不会跳转到方法体以外的字节码指令上、方法体中的类型转换是有效的等。
4.  符号引用验证：发生在解析阶段将符号引用转为直接引用的时候，确保解析动作能正确执行。如符号引用中通过字符串描述的全限定名是否能找到对应类。

## 准备

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中

## 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

       符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

       直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。

### 解析触发的时机

1.  可能会在初始化阶段后才开始
2.  在验证阶段会触发, 验证类格式, 符号引用
3.  在准备阶段会触发, 需要知道生成的class对象的大小, 需要进行解析

## 初始化

### 初始化时机

1.    遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：

-   使用new关键字实例化对象的时候；

-   读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；

-   调用一个类的静态方法的时候。

```
    newarray指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，new String[ ]只会直接触发String[ ]类的初始化，也就是触发对类[Ljava.lang.String的初始化，而直接不会触发String类的初始化
```

2.  使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

3.  当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4.  当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

5.  当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

## 使用

## 卸载

满足下面的情况，类就会被卸载:

1.  该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例
2.  加载该类的ClassLoader已经被回收
3.  该类对应的java.lang.Class对象没有任何地方被引用，无法再任何地方通过反射访问该类的方法

## 资料引用

1.  [方法符合引用转直接引用](https://www.zhihu.com/question/30300585)
2.  [字段符合引用转直接引用](https://www.zhihu.com/question/50258991/answer/120450561)