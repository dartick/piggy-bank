# GC调优策略

## 调优指标

1. 高可用。完成多少个9
2. 低延迟。要求多少毫秒内响应
3. 高吞吐。TPS要求多少

如果满足下面的指标，**则一般不需要进行 GC 优化：**

> MinorGC 执行时间不到**50ms**； Minor GC 执行不频繁，约**10秒一次**； Full GC 执行时间不到**1s**； Full GC 执行频率不算频繁，不低于**10分钟1次**。

## 调优案例

### 堆大小

根据各区域活跃数据的大小来设置， **活跃数据的大小**是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小：



| 空间   | 倍数                                    |
| :----- | :-------------------------------------- |
| 总大小 | **3-4** 倍活跃数据的大小                |
| 新生代 | **1-1.5** 活跃数据的大小                |
| 老年代 | **2-3** 倍活跃数据的大小                |
| 永久代 | **1.2-1.5** 倍Full GC后的永久代空间占用 |



例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：

> 总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*

### young gc 频繁

举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/f6e7326e.png)

那么有(50ms+25ms)/T比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，如果时间T内发生N次GC，**受GC影响请求占比=(接口响应时间+GC时间)×N/T** 。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。

解决方案：扩大young区

### CMS remark阶段STW耗时长

原因在于：**并发预清理阶段**没有等到young gc（在Eden区使用超过2M时启动才会启动），导致young区对象过多，remark扫描效率低下

加大CMSScavengeBeforeRemark参数