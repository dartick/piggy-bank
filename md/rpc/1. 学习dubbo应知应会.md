# 学习dubbo应知应会

## 概念

### RPC

#### RPC是什么, 为什么要用RPC

RPC ( Remote Procedure Call ) 是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。

#### 实现RPC需要解决什么问题

RPC的调用过程如下:

![img](https://pic4.zhimg.com/80/45366c44f775abfd0ac3b43bccc1abc3_hd.jpg)

1. Client像调用本地服务似的调用远程服务； 
2.  Client stub接收到调用后，将方法、参数序列化 
3. 客户端通过sockets将消息发送到服务端 
4. Server stub 收到消息后进行解码（将消息对象反序列化） 
5. Server stub 根据解码结果调用本地的服务 
6. 本地服务执行(对于服务端来说是本地执行)并将结果返回给Server stub 
7. Server stub(skeleton-骨架)将返回结果打包成消息（将结果消息对象序列化） 
8. 服务端通过sockets将消息发送到客户端 
9. Client stub接收到结果消息，并进行解码（将结果消息发序列化） 
10. 客户端得到最终结果。

那么RPC需要解决:

1. 通讯问题. 主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。
2. 寻址. A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口号，方法的名称是什么，这样才能完成调用，比如基于WEB服务协议的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。
3. 序列化. 当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于 二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组(marshal)，通过寻址和传输将序列化的二进制发送给B服务器。

> endpoint URI: 远程服务的具体调用url
>
> UDDI服务: 是一个公共的注册表，旨在以一种结构化的方式来保存有关各公司及其服务的信息。通过 UDDI，人们可以发布和发现有关某个公司及其 Web 服务的信息。

#### Stub的理解

单纯对Stub的翻译是存根, 树墩, 还是不理解, 而百度百科对存根的解释是: 票据、证件等开出后所留的底子(啥玩意儿). 然后知乎搜了一下, 发现了**R大**(天了乎)的[回答](https://www.zhihu.com/question/24844900): **它们并不是最终的调用目标，而是做一些简单的处理之后“跳”到真正的目标去。** R大的回答肯定是无条件信服的, 那么这样的话, 重新再理解, stub对应的翻译是树墩, client stub就相当于跳板, 并没有做最终的调用, 而是发送到远程服务去做真正的调用, 这样理解就通了.

#### RPC处于OSI的哪一层

在OSI模型中, RPC属于会话层, 会话层的功能是给应用程序创建, 关闭和管理会话的.也就是应用程序在发起RPC调用时, 不需要关心会话相关的事情. 但RPC可通过Http来实现, 而Http是处于应用层协议, 那有比应用层还要高的层次吗? 实际上RPC并不属于网络协议的范畴, 在RPC的实现中, 需要用到通讯协议, 通讯协议可以使用http, 也可以自定义. 那OSI为什么要把RPC定义在会话层呢?  如果这样理解的话就通了, OSI定义的是RPC需要的通讯协议属于会话层, 这样一想, http囊括了会话层, 所以可以通过http来实现RPC.

> 会话层与传输层的区别?
>
> 传输层: 两个人要通信了，由于传输途径的限制，一封信会被切割为一个一个段落（segment）。那么其中一个段落传丢了怎么办？要不要重传？每个段落，要顺讯到达吗？这些就是 TCP/UDP 的区别。传输层用来解决这些问题。
>
> 会话层: 既然两个人要通信，如何开始？过了一段时间，不想继续通信了，如何结束？这些都是会话层要处理的。

![img](https://img-blog.csdn.net/20140924202143732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFpZ29vY24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### RMI

RMI的全称为 Java远程方法调用(Java Remote Method Invocation), 所以也是远程调用, 但是专门属于java语言里的, 能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。所以其与RPC的关系是, RMI属于RPC在面向对象程序设计中更加具体的定义, 即 RMI = RPC + 面向对象. 那么更加具体的地方在于:

1. 仅限于Java语言

 	2.	以远程接口的形式进行调用

![img](https://img-blog.csdn.net/20130813104359359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

RMI调用过程:

1. 客户对象调用客户端辅助对象上的方法

2. 客户端辅助对象打包调用信息（变量，方法名），通过网络发送给服务端辅助对象

3. 服务端辅助对象将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象

4. 调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象

5. 服务端辅助对象将结果打包，发送给客户端辅助对象

6. 客户端辅助对象将返回值解包，返回给客户对象

7. 客户对象获得返回值

### Dubbo

Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。

#### 为什么需要RPC框架

从应用的架构演讲来讲解:

##### 单体架构

早期的Wed应用开发方式，通常MVC层、Service层和ORM层整合在同一个Web应用中，在遭遇流量压力时，只能进行简单的机器集群。一个典型单体应用结构如下图所示：

![è¾å¥å¾çè¯´æ](https://static.oschina.net/uploads/img/201611/06161029_WlU6.png)

将应用程序的所有功能都打包成一个独立的单元，可以是JAR、WAR、EAR或其它归档格式。

优点: IDE友好, 便于共享, 易于测试, 容易部署

缺点: 妨碍持续交付(构建和部署时间也相应地比较长), 需求变更困难(迁一而动全身),  共生共灭(业务模块相互影响),

水平扩展能力弱(单一业务模块无法水平扩展)

##### 微服务

引用 ThoughtWorks 公司的首席科学家 Martin Fowler 的一段话：微服务架构风格是一种将单个应用程序作为一套小型服务开发的方法，每种应用程序都在自己的进程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。 这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。 这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术。

优点: 独立部署，灵活扩展, 敏捷交付(服务由小研发团队负责微服务设计、开发、测试、部署、线上治理、灰度发布和下线，运维整个生命周期支撑，实现真正的DevOps)

缺点: 服务数量激增, 调用链路变长, 服务监控复杂, 测试复杂度增加, 数据一致性保证变得困难

##### 微服务与面向服务架构(SOA) 的区别

SOA架构是一种粗粒度, 松耦合的服务架构, 更多的是强调的是异构系统之间的通信和解耦合，而微服务架构强调的是系统按业务边界做细粒度的拆分和部署。

拆分系统之后, 系统间的通讯则是需要解决的问题, 当然, 可以采用http来进行通讯, 在系统交互不多的情况下, 使用http进行通讯简单、直接、开发方便, 但是当子系统, 交互接口非常多的情况下, 使用http则会耗损性能, 一次请求就是一次TCP链接, 开销大, 而使用RPC框架则可以使用自定义的协议进行长连接解决该问题, 同时, RPC有注册中心, 监控, 接口上下线等功能.

## Dubbo接口的测试

以单一微服务的维度来进行研发团队的分工, 则会导致测试困难的问题, 比如订单服务调用了支付服务的一个dubbo接口, 当支付服务对dubbo接口进行了改造, 那么支付团队的测试则需要对其进行测试, 但是整个调用的入口是订单服务, 那么支付的测试则需要知道订单服务上的流程才可进行测试, 那么便会造成了测试上的困难. 有两种方式解决该问题:

1. 开发人员针对dubbo接口编写http接口
2. 测试人员使用[jmeter插件](https://www.cnkirito.moe/dubbo-perf-benchmark/)

## Dubbo的配置

dubbo的配置方式有多种, 以下优先级由高到低:

1. JVM System Properties，通过java命令启动应用的时候, 可以轻易地重写配置, 例如Application的配置: -Ddubbo.application.name=foo;
2. Externalized Configuration. 外部配置(v2.7.0以上支持), 即配置中心的方式；
3. ServiceConfig、ReferenceConfig等编程接口采集的配置. 生成这些配置实例可以通过API或者XML的方式.
4. Properties配置. 默认配置，仅仅作用于以上两者没有配置时。

### 配置之间的关系

![dubbo-config](http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-config.jpg)

| 标签                                                         | 用途         | 解释                                                         |
| ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ |
| `<dubbo:service/>`                                           | 服务配置     | 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心 |
| `<dubbo:reference/>`[[2\]](http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html#fn2) | 引用配置     | 用于创建一个远程服务代理，一个引用可以指向多个注册中心       |
| `<dubbo:protocol/>`                                          | 协议配置     | 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受 |
| `<dubbo:application/>`                                       | 应用配置     | 用于配置当前应用信息，不管该应用是提供者还是消费者           |
| `<dubbo:module/>`                                            | 模块配置     | 用于配置当前模块信息，可选                                   |
| `<dubbo:registry/>`                                          | 注册中心配置 | 用于配置连接注册中心相关信息                                 |
| `<dubbo:monitor/>`                                           | 监控中心配置 | 用于配置连接监控中心相关信息，可选                           |
| `<dubbo:provider/>`                                          | 提供方配置   | 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选 |
| `<dubbo:consumer/>`                                          | 消费方配置   | 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选      |
| `<dubbo:method/>`                                            | 方法配置     | 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息   |
| `<dubbo:argument/>`                                          | 参数配置     | 用于指定方法参数配置                                         |

![å²ä¸æå¼ºDubboé¢è¯28é¢ç­æ¡è¯¦è§£ï¼æ ¸å¿åè½+æå¡æ²»ç+æ¶æè®¾è®¡ç­](https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731230038_32312.jpg)

### 不同粒度配置的覆盖关系

以 timeout 为例，下图显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似：

- 方法级优先，接口级次之，全局配置再次之。
- 如果级别一样，则消费方优先，提供方次之。

其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。

![dubbo-config-override](http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-config-override.jpg)

### [配置详解](http://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html)

大体上可以分为三大类:

- 服务发现：表示该配置项用于服务的注册与发现，目的是让消费方找到提供方。

- 服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。
- 性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。

## 引用

1. [谁能用通俗的语言解释一下什么是 RPC 框架？](https://www.zhihu.com/question/25536695)
2. [Dubbo XML 配置](http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html)
3. [微服务架构演进](https://my.oschina.net/xuxueli/blog/782478)

​	

